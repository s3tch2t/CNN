# -*- coding: utf-8 -*-
"""inference.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Mw8eJTu_zWCK9luWWL87yBhl6XU7w9bH
"""

# Commented out IPython magic to ensure Python compatibility.
import warnings
warnings.filterwarnings('ignore')

import random
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import plotly
import plotly.graph_objects as go
# %matplotlib inline

import os

from sklearn.calibration import calibration_curve
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix
import itertools
from torch.utils.data import DataLoader, TensorDataset
import torch
import torchvision
import torch.nn as nn
import torch.nn.functional as F
from torch.autograd import Variable
from torch.optim import lr_scheduler

np.random.seed(42)

test = pd.read_csv('/kaggle/input/mnist-digit/test.csv', dtype=np.float32)

BATCH_SIZE = 128
EPOCHS = 8

test_tensor = torch.utils.data.TensorDataset(X_test, torch.zeros(len(X_test)))  # Adding dummy labels

test_loader = torch.utils.data.DataLoader(test_tensor,
                                          batch_size=BATCH_SIZE,
                                          shuffle=False)

class CNNModel(nn.Module):
    def __init__(self):
        super(CNNModel, self).__init__()

        self.c1 = nn.Conv2d(in_channels=1, out_channels=16, kernel_size=(5,5), stride=1, padding=0)
        self.relu1 = nn.ReLU()

        self.maxpool1 = nn.MaxPool2d(kernel_size=(2,2))

        self.dropout1 = nn.Dropout(0.25)

        self.c2 = nn.Conv2d(in_channels=16, out_channels=32, kernel_size=(3,3), stride=1, padding=0)
        self.relu2 = nn.ReLU()

        self.maxpool2 = nn.MaxPool2d(kernel_size=(2,2))

        self.dropout2 = nn.Dropout(0.25)

        self.fc1 = nn.Linear(32*5*5, 256)

        self.dropout3 = nn.Dropout(0.25)

        self.fc2 = nn.Linear(256, 10)

    def forward(self, x):

        out = self.c1(x)
        out = self.relu1(out)
        out = self.maxpool1(out)
        out = self.dropout1(out)

        out = self.c2(out)
        out = self.relu2(out)
        out = self.maxpool2(out)
        out = self.dropout2(out)

        out = out.view(out.size(0), -1)
        out = self.fc1(out)
        out = self.dropout3(out)
        out = self.fc2(out)

        return out

model = CNNModel()

criterion = nn.CrossEntropyLoss()

exp_lr_scheduler = lr_scheduler.StepLR(optimizer, step_size=3, gamma=0.5)

def test(data_loader):

    print("Testing...")

    model.eval()
    test_preds = torch.LongTensor()
    test_proba = torch.FloatTensor()

    test_running_loss = 0.0
    test_running_correct = 0

    with torch.no_grad():
        for data, target in data_loader:
            data, target = Variable(data.view(BATCH_SIZE, 1, 28, 28)), Variable(target).long()

            output = model(data)
            loss = criterion(output, target)

            test_running_loss += loss.item()
            pred = output.data.max(1, keepdim=True)[1]
            proba = torch.nn.functional.softmax(output.data, dim=1)

            test_running_correct += pred.eq(target.data.view_as(pred)).cpu().sum()

            test_preds = torch.cat((test_preds, pred), dim=0)
            test_proba = torch.cat((test_proba, proba), dim=0)

    test_loss = test_running_loss / len(data_loader.dataset)
    test_accuracy = 100. * test_running_correct / len(data_loader.dataset)

    return test_loss, test_accuracy, test_preds, test_proba

test_loss, test_accuracy, test_preds, test_proba = test(test_loader)

print(f'Test Loss: {test_loss:.4f}, Test Acc: {test_accuracy:.2f}\n')

def plot_confusion_matrix(confusion_matrix,
                          cmap=plt.cm.Reds):

    classes = range(10)

    plt.figure(figsize=(8,8))
    plt.imshow(confusion_matrix,
               interpolation='nearest',
               cmap=cmap)
    plt.title('Confusion matrix')
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=45)
    plt.yticks(tick_marks, classes)

    thresh = confusion_matrix.max() / 2.
    for i, j in itertools.product(range(confusion_matrix.shape[0]), range(confusion_matrix.shape[1])):
        plt.text(j, i, confusion_matrix[i, j],
                 horizontalalignment="center",
                 color="white" if confusion_matrix[i, j] > thresh else "black")

    plt.tight_layout()
    plt.ylabel('True label')
    plt.xlabel('Predicted label')

y_pred_classes = val_preds[EPOCHS - 1].cpu().numpy().ravel()

cm = confusion_matrix(y_val, y_pred_classes)

plot_confusion_matrix(cm)